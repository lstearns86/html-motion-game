<html>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta names="apple-mobile-web-app-status-bar-style" content="black-translucent" />


<head>
<title>HTML5 Portable Device Motion Experiment</title>

<style type="text/css">
#mainCanvas
{
width: 100%;
height: 100%;
margin: 0px;
padding: 0px;
position: absolute;
z-index: 0;
}
#secondCanvas
{
width: 100%;
height: 100%;
margin: 0px;
padding: 0px;
position: absolute;
z-index: -1;
}
</style>

<script type="text/javascript">

var GameModes = { Loading: 0, NewGame: 1, Playing: 2 }
var mode = GameModes.Loading;

var minPitch = -60;
var maxPitch = 60;

var canvas, canvasBg;
var pitch, yaw;
var targetYaw, targetPitch;
var centerPercent;

var hintVisibility, hintDirection, prevYaw, prevPitch;

var bgImg;

var startTime, totalElapsedTime;

function initialize()
{
	pitch = 0; yaw = 0;
	targetYaw = 0;
	targetPitch = 0;
	centerPercent = 0;
	
	hintVisibility = 0;

	canvas = document.getElementById('mainCanvas');
	canvasBg = document.getElementById('secondCanvas');
	if(window.DeviceOrientationEvent)
		window.addEventListener('deviceorientation', orientationChanged, false);
		
	window.addEventListener('mousedown', function(e) { click(getPosition(e)); }, false);
	window.addEventListener('touchstart', function(e) { click(getPosition(e.touches[0])); }, false);
	window.addEventListener('touchmove', function(e) { e.preventDefault(); }, false);
	
	loading = true;
	bgImg = new Image();
	bgImg.onload = function() { mode = GameModes.NewGame; draw(); drawBg(); }
	bgImg.src = "panorama1.jpg"; //Photo by DAVID ILIFF. License: CC-BY-SA 3.0. Downloaded from wikipedia.org
	
	resize();
	update();
}

function resize()
{
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	canvas.style.left = '0px';
	canvas.style.top = '0px';
	
	canvasBg.width = window.innerWidth;
	canvasBg.height = window.innerHeight;
	canvasBg.style.left = '0px';
	canvasBg.style.top = '0px';

	draw();
	drawBg();
}

function draw()
{
	var cxt = canvas.getContext('2d');
	
	// Store the current transformation matrix
	//cxt.save();

	// Use the identity matrix while clearing the canvas
	//cxt.setTransform(1, 0, 0, 1, 0, 0);
	//cxt.clearRect(0, 0, canvas.width, canvas.height);

	// Restore the transform
	//cxt.restore();
	
	canvas.width = canvas.width; // may be faster for some browsers
	
	if(mode == GameModes.Loading)
	{
		cxt.font = "24pt Arial";
		cxt.fillStyle = "#000000";
		cxt.fillText('Loading...', window.innerWidth / 2 - cxt.measureText("Loading...").width / 2, window.innerHeight / 2);
	}
	else if(mode == GameModes.NewGame)
	{
		cxt.fillStyle = "#4455cc";
		cxt.globalAlpha = 0.3;
		cxt.roundRect(canvas.width / 2 - 150, canvas.height / 2 - 50, 300, 100, 15);
		cxt.fill();
		cxt.globalAlpha = 1;
		cxt.strokeStyle = "#ffffff";
		cxt.lineWidth = 2;
		cxt.roundRect(canvas.width / 2 - 150, canvas.height / 2 - 50, 300, 100, 15);
		cxt.stroke();
		
		cxt.font = "24pt Arial";
		cxt.fillStyle = "#ffffff";
		cxt.fillText('Start New Game', canvas.width / 2 - cxt.measureText("Start New Game").width / 2, canvas.height / 2 + 12);
	}
	else if(mode == GameModes.Playing)
	{
		var angleX = yaw - targetYaw;
		while(angleX < -180) angleX += 360;
		while(angleX > 180) angleX -= 360;
		var angleY = pitch - targetPitch;
		if(Math.abs(angleX) < 40 && Math.abs(angleY) < 40)
		{
			var x = canvas.width / 2 + Math.sin(angleX * Math.PI / 180) * canvas.width;
			var y = canvas.height / 2 - Math.sin(angleY * Math.PI / 180) * canvas.height;
			
			if(centerPercent > 0)
			{
				cxt.beginPath();
				cxt.fillStyle = "#00ff00";
				cxt.moveTo(x, y);
				cxt.arc(x, y, 110, 0, 2 * Math.PI * centerPercent / 100, false);
				cxt.lineTo(x, y);
				cxt.fill();
			}
			
			cxt.beginPath();
			cxt.fillStyle = "#ff0000";
			cxt.arc(x, y, 100, 2 * Math.PI, false);
			cxt.fill();
			
			cxt.beginPath();
			cxt.fillStyle = "#ffffff";
			cxt.arc(x, y, 80, 2 * Math.PI, false);
			cxt.fill();
			
			cxt.beginPath();
			cxt.fillStyle = "#ff0000";
			cxt.arc(x, y, 60, 2 * Math.PI, false);
			cxt.fill();
			
			cxt.beginPath();
			cxt.fillStyle = "#ffffff";
			cxt.arc(x, y, 40, 2 * Math.PI, false);
			cxt.fill();
			
			cxt.beginPath();
			cxt.fillStyle = "#ff0000";
			cxt.arc(x, y, 20, 2 * Math.PI, false);
			cxt.fill();
		}
		
		if(hintVisibility > 0)
		{
			angleX = yaw - prevYaw;
			while(angleX < -180) angleX += 360;
			while(angleX > 180) angleX -= 360;
			angleY = pitch - prevPitch;
			if(Math.abs(angleX) < 40 && Math.abs(angleY) < 40)
			{
				var x = canvas.width / 2 + Math.sin(angleX * Math.PI / 180) * canvas.width;
				var y = canvas.height / 2 - Math.sin(angleY * Math.PI / 180) * canvas.height;
				
				cxt.save();
				cxt.globalAlpha = hintVisibility
				cxt.translate(x, y);
				cxt.rotate(-hintDirection * Math.PI / 180);
				cxt.fillStyle = "#ffffff";
				cxt.beginPath();
				cxt.moveTo(-50, -5);
				cxt.lineTo(-50, 5);
				cxt.lineTo(25, 5);
				cxt.lineTo(25, 25);
				cxt.lineTo(50, 0);
				cxt.lineTo(25, -25);
				cxt.lineTo(25, -5);
				cxt.lineTo(-25, -5);
				cxt.fill();
				cxt.globalAlpha = 1;
				cxt.restore();
			}
		}
		
		// draw the targeting reticle
		cxt.beginPath();
		cxt.strokeStyle = "#000000";
		cxt.arc(canvas.width/2, canvas.height/2, 10, 2 * Math.PI, false);
		cxt.stroke();
		
		// debug info, uncomment as needed
		/*cxt.font = "24pt Arial";
		cxt.fillStyle = "#000000";
		cxt.fillText('Pitch: ' + Math.round(pitch).toString(), 10, 30);
		cxt.fillText('Yaw: ' + Math.round(yaw).toString(), 10, 60);
		cxt.fillText('Target Yaw: ' + Math.round(targetYaw).toString(), 10, 90);
		cxt.fillText('Target Pitch: ' + Math.round(targetPitch).toString(), 10, 120);
		cxt.fillText('Prev Yaw: ' + Math.round(prevYaw).toString(), 10, 150);
		cxt.fillText('Prev Pitch: ' + Math.round(prevPitch).toString(), 10, 180);
		cxt.fillText('Hint Direction: ' + Math.round(hintDirection).toString(), 10, 210);
		cxt.fillText('Orientation: ' + Math.round(window.orientation).toString(), 10, 240);*/
	}
}

function drawBg()
{
	var cxt = canvasBg.getContext('2d');
	
	// Store the current transformation matrix
	//cxt.save();

	// Use the identity matrix while clearing the canvas
	//cxt.setTransform(1, 0, 0, 1, 0, 0);
	//cxt.clearRect(0, 0, canvas.width, canvas.height);

	// Restore the transform
	//cxt.restore();
	
	//canvasBg.width = canvasBg.width; // may be faster for some browsers
	
	// scale background image for better augmented reality experience
	var scaleFactor = 1;
	switch(window.orientation)
	{
		case 0: scaleFactor = 3; break;
		case 90:
		case -90: scaleFactor = 2; break;
	}
	if(canvas.width > canvas.height) scaleFactor = 2;
	var bgWidth = scaleFactor * bgImg.width;
	var bgHeight = scaleFactor * bgImg.height;
	
	// position and draw background image (twice for seamless panorama)
	var bgX = bgWidth * yaw / 360;
	var bgY = -bgHeight * (pitch + 90 - 40) / 180;
	if(bgY > 0) bgY = 0;
	if(bgY + bgHeight < canvasBg.height) bgY = canvasBg.height - bgHeight;
	cxt.drawImage(bgImg, bgX, bgY, bgWidth, bgHeight);
	cxt.drawImage(bgImg, bgX - bgWidth, bgY, bgWidth, bgHeight);
}

function orientationChanged(e)
{
	if(e.alpha != null)
	{		
		if(window.orientation == 90)
		{
			pitch = e.gamma + 90;
			yaw = e.alpha;
		}
		else if(window.orientation == -90)
		{
			pitch = -e.gamma + 90;
			yaw = e.alpha;
		}
		else if(window.orientation == 0)
		{
			// matrix derivations adapted from dev.w3.org/geo/api/spec-source-orientation.html
			// R = ABCr
			//     A is the 3D rotation matrix around the Z axis
			//     B is the 3D rotation matrix around the X axis
			//     C is the 3D rotation matrix around the Y axis
			//     r is the 3D reference vector in device coordinates
			//     R is the calculated 3D vector in world coordinates
		
			var a = e.alpha * Math.PI / 180;
			var b = e.beta * Math.PI / 180;
			var c = e.gamma * Math.PI / 180;
			
			var Rx = -Math.cos(a) * Math.sin(c) - Math.sin(a) * Math.sin(b) * Math.cos(c);
			var Ry = -Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.sin(b) * Math.cos(c);
			var Rz = -Math.cos(b) * Math.cos(c);
			
			yaw = Math.atan2(Rx, Ry);
			pitch = Math.atan2(Math.sqrt(Rx * Rx + Ry * Ry), Rz);
			
			yaw = -yaw * 180 / Math.PI;
			pitch = pitch * 180 / Math.PI - 90;
		}
		
		if(yaw > 180) yaw -= 360;
	}
}

function click(p)
{
	if(mode = GameModes.NewGame && 
	   p.x >= canvas.width / 2 - 150 && p.x < canvas.width / 2 + 150 &&
	   p.y >= canvas.height / 2 - 50 && p.y < canvas.height / 2 + 50)
	{
		mode = GameModes.Playing;
		drawBg();
		draw();
	}
}

function update()
{
	if(mode == GameModes.Playing)
	{
		var angleX = yaw - targetYaw;
		while(angleX < -180) angleX += 360;
		while(angleX > 180) angleX -= 360;
		var angleY = pitch - targetPitch;
		if(Math.abs(angleX) < 5 && Math.abs(angleY) < 5)
			centerPercent += 3; // use to control how long the target needs to be centered
		else
			centerPercent = 0;
			
		hintVisibility -= 0.02;
		
		if(centerPercent >= 100)
		{
			hintVisibility = 1;
			prevYaw = targetYaw;
			prevPitch = targetPitch;
		
			targetYaw = Math.random() * 360 - 180;
			//targetYaw = Math.random() * 60 - 30;
			targetPitch = Math.random() * (maxPitch - minPitch) + minPitch;
			centerPercent = 0;
			
			// convert to latitude and longitude framework
			var lon1 = prevYaw;
			var lon2 = targetYaw;
			var lat1 = -prevPitch;
			var lat2 = -targetPitch;
			
			// find the difference in longitude for the great circle equations
			var dLon = lon2 - lon1;
			while(dLon < -180) dLon += 360;
			while(dLon > 180) dLon -= 360;
			
			// convert to degrees
			lon1 = lon1 * Math.PI / 180;
			lon2 = lon2 * Math.PI / 180;
			lat1 = lat1 * Math.PI / 180;
			lat2 = lat2 * Math.PI / 180;
			dLon = dLon * Math.PI / 180;
			
			// find the great circle bearing between targets
			// great circle equation adapted from http://www.movable-type.co.uk/scripts/latlong.html
			var bearing = Math.atan2(Math.sin(dLon) * Math.cos(lat2), 
									 Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon));
			
			// use the calculated bearing to create a hint arrow for the direction the user should turn
			hintDirection = bearing * 180 / Math.PI;
			hintDirection = hintDirection + 90;
			if(hintDirection > 180) hintDirection -= 360;
		}
	
		draw();
	}
	
	if(mode != GameModes.Loading)
		drawBg();
	
	requestAnimFrame(update);
}

// shim layer with setTimeout fallback
// borrowed from Paul Irish at http://paulirish.com/2011/requestanimationframe-for-smart-animating/
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       || 
		  window.webkitRequestAnimationFrame || 
		  window.mozRequestAnimationFrame    || 
		  window.oRequestAnimationFrame      || 
		  window.msRequestAnimationFrame     || 
		  function( callback ){
			window.setTimeout(callback, 1000 / 60);
		  };
})();

// adds a canvas function for drawing a rounded rectangle
// borrowed from stackoverflow user Corgalore in conversation found at http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
CanvasRenderingContext2D.prototype.roundRect = function(sx,sy,w,h,r) {
    var r2d = Math.PI/180;
	var ex = sx + w;
	var ey = sy + h;
    if( ( ex - sx ) - ( 2 * r ) < 0 ) { r = ( ( ex - sx ) / 2 ); } //ensure that the radius isn't too large for x
    if( ( ey - sy ) - ( 2 * r ) < 0 ) { r = ( ( ey - sy ) / 2 ); } //ensure that the radius isn't too large for y
    this.beginPath();
    this.moveTo(sx+r,sy);
    this.lineTo(ex-r,sy);
    this.arc(ex-r,sy+r,r,r2d*270,r2d*360,false);
    this.lineTo(ex,ey-r);
    this.arc(ex-r,ey-r,r,r2d*0,r2d*90,false);
    this.lineTo(sx+r,ey);
    this.arc(sx+r,ey-r,r,r2d*90,r2d*180,false);
    this.lineTo(sx,sy+r);
    this.arc(sx+r,sy+r,r,r2d*180,r2d*270,false);
    this.closePath();
}

// get the mouse or touch position from the event variable for various browsers
// adapted from multiple answers at stackoverflow.com
function getPosition(e) { return getCanvasPosition(e, canvasBg); }
function getCanvasPosition(e, canvas)
{
	var x, y;
	
	if (e.layerX || e.layerX == 0) { // Firefox, Chrome, IE9, Desktop Safari
		x = e.layerX;
		y = e.layerY;
		x -= canvas.offsetLeft;
		y -= canvas.offsetTop;
	} else if (e.offsetX || e.offsetX == 0) { // Opera
		x = e.offsetX;
		y = e.offsetY;
	} else { // iOS Safari
		x = e.pageX;
		y = e.pageY;
		x -= canvas.offsetLeft;
		y -= canvas.offsetTop;
	}
	
	return {x: x, y: y};
}

</script>

</head>


<body onload="initialize()" onresize="resize();">
<div id="content">

<canvas id="mainCanvas" width="600" height="600" >
This application uses the HTML 5 Canvas element. Please update your browser to the most recent version or download one of these supported alternatives:
<br/><br/>
<a href="http://www.google.com/chrome">Google Chrome 4.0+</a><br/>
<a href="http://www.mozilla.org/en-US/firefox/new/">Mozilla Firefox 2.0+</a><br/>
<a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home">Microsoft Internet Explorer 9.0+</a><br/>
<a href="http://www.apple.com/safari/">Apple Safari 3.1+</a><br/>
<a href="http://www.opera.com/">Opera 9.0+</a><br/>
<br/>
</canvas>
<canvas id="secondCanvas"></canvas>

</div>
</body>
</html>